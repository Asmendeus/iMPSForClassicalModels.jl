"""
    struct AdjointLocalTensor{R} <: AbstractLocalTensor{R}
        A::AbstractTensorMap
    end

Lazy wrapper type for adjoint R-leg local tensor.

Convention (' marks codomain):

                         3               4                   R
                         |               |                   |
    2 -- B -- 1'    2 -- B -- 1'    3 -- B -- 2'    (R-1) -- B  -- (R-2)'
                                         |                 / | \\
                                         1'              1' ... (R-3)'

# Constructors
    AdjointLocalTensor(::AbstractTensorMap)
    AdjointLocalTensor{R}(::AbstractTensorMap)
"""
struct AdjointLocalTensor{R} <: AbstractLocalTensor{R}
    A::AbstractTensorMap

    function AdjointLocalTensor(A::AbstractTensorMap)
        if numin(A) == 1 && numout(A) == 1
            return new{2}(A)
        elseif numin(A) == 2 && numout(A) > 0
            R = numind(A)
            return new{R}(A)
        else
            throw(ArgumentError("The space $(space(A)) does not conform to `AdjointLocalTensor` space"))
        end
    end
    function AdjointLocalTensor{R}(A::AbstractTensorMap) where R
        if R == 2
            (numin(A) == 1 && numout(A) == 1) || throw(ArgumentError("The space $(space(A)) does not conform to `AdjointLocalTensor{$R}` space"))
        elseif R > 2
            (numin(A) == 2 && numout(A) == R-2 > 0) || throw(ArgumentError("The space $(space(A)) does not conform to `AdjointLocalTensor{$R}` space"))
        else
            throw(ArgumentError("The space $(space(A)) does not conform to `AdjointLocalTensor{$R}` space"))
        end
        return new{R}(A)
    end
end
adjoint(A::LocalTensor) = AdjointLocalTensor(A.A')
adjoint(A::AdjointLocalTensor)::LocalTensor = A.A'

const AdjointBondTensor = AdjointLocalTensor{2}
const AdjointMPSTensor = AdjointLocalTensor{3}
const AdjointMPOTensor = AdjointLocalTensor{4}


# ========== AdjointBondTensor base math ==========
inv(A::BondTensor) = AdjointBondTensor(inv(A.A))
inv(A::AdjointBondTensor) = BondTensor(inv(A.A))

function Base.:(*)(A::AdjointBondTensor, B::AdjointBondTensor)
    @tensor E[-1; -2] := A.A[1 -2] * B.A[-1 1]
    return typeof(B)E
end
function Base.:(*)(A::AdjointBondTensor, B::AdjointLocalTensor{R}) where R
    if R == 3
        @tensor E[-1; -2 -3] := A.A[1 -2] * B.A[-1 1 -3]
    elseif R == 4
        @tensor E[-1 -2; -3 -4] := A.A[1 -3] * B.A[-1 -2 1 -4]
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # str_legs_E = "-1" * prod([" -$i" for i in 2:R-2]) * "; -$(R-1) -$R"
        # str_legs_B = prod(["-$i " for i in 1:R-2]) * "1 -$R"
        # str_expr = "@tensor E[$str_legs_E] := A.A[1 -$(R-1)] * B.A[$str_legs_B]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
    return typeof(B)(E)
end
function Base.:(*)(A::AdjointLocalTensor{R}, B::AdjointBondTensor) where R
    if R == 3
        @tensor E[-1; -2 -3] := A.A[1 -2 -3] * B.A[-1 1]
    elseif R == 4
        @tensor E[-1 -2; -3 -4] := A.A[-1 1 -3 -4] * B.A[-2 1]
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # str_legs_E = "-1" * prod([" -$i" for i in 2:R-2]) * "; -$(R-1) -$R"
        # str_legs_A = prod(["-$i " for i in 1:R-3]) * "1 -$(R-1) -$R"
        # str_expr = "@tensor E[$str_legs_E] := A.A[$str_legs_A] * B.A[-$(R-2) 1]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
    return typeof(A)(E)
end

# ========== multiplication of LocalTensor with AdjointBondTensor ==========
# Notice: if A isa AdjointBondTensor && B isa LocalTensor{R}, multiplication diagram is
#             -- B --
#            |   |
#  A * B  =  |
#            |
#             -- A --
# Other cases of one adjoint and one non-adjoint are similar.
function Base.:(*)(A::AdjointBondTensor, B::LocalTensor{R}) where R
    if R == 3
        @tensor E[-1 -2; -3] := A.A[-1 1] * B.A[1 -2 -3]
    elseif R == 4
        @tensor E[-1 -2; -3 -4] := A.A[-1 1] * B.A[1 -2 -3 -4]
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # str_domain_E = prod([" -$i" for i in 3:R])
        # str_legs = "1" * prod([" -$i" for i in 2:R])
        # str_expr = "@tensor E[-1 -2;$str_domain_E] := A.A[-1 1] * B.A[$str_legs]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
    return typeof(B)(E)
end
function Base.:(*)(A::LocalTensor{R}, B::AdjointBondTensor) where R
    if R == 3
        @tensor E[-1 -2; -3] := A.A[-1 -2 1] * B.A[1 -3]
    elseif R == 4
        @tensor E[-1 -2; -3 -4] := A.A[-1 -2 -3 1] * B.A[1 -4]
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # str_domain_E = prod([" -$i" for i in 3:R])
        # str_legs = prod(["-$i " for i in 1:R-1]) * " 1"
        # str_expr = "@tensor E[-1 -2;$str_domain_E] := A.A[$str_legs] * B.A[1 -$R]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
    return typeof(A)(E)
end

# ========== multiplication of AdjointLocalTensor with BondTensor ==========
function Base.:(*)(A::BondTensor, B::AdjointLocalTensor{R}) where R
    if R == 3
        @tensor E[-1; -2 -3] := A.A[-2 1] * B.A[-1 1 -3]
    elseif R == 4
        @tensor E[-1 -2; -3 -4] := A.A[-3 1] * B.A[-1 -2 1 -4]
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # str_legs_E = "-1" * prod([" -$i" for i in 2:R-2]) * "; -$(R-1) -$R"
        # str_legs_B = prod(["-$i " for i in 1:R-2]) * "1 -$R"
        # str_expr = "@tensor E[$str_legs_E] := A.A[-$(R-1) 1] * B.A[$str_legs_B]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
    return typeof(B)(E)
end
function Base.:(*)(A::AdjointLocalTensor{R}, B::BondTensor) where R
    if R == 3
        @tensor E[-1; -2 -3] := A.A[1 -2 -3] * B.A[1 -1]
    elseif R == 4
        @tensor E[-1 -2; -3 -4] := A.A[-1 1 -3 -4] * B.A[1 -2]
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # str_legs_E = "-1" * prod([" -$i" for i in 2:R-2]) * "; -$(R-1) -$R"
        # str_legs_A = prod(["-$i " for i in 1:R-3]) * "1 -$(R-1) -$R"
        # str_expr = "@tensor E[$str_legs_E] := A.A[$str_legs_A] * B.A[1 -$(R-2)]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
    return typeof(A)(E)
end
