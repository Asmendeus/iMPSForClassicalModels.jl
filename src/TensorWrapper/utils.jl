"""
    isadjoint(::AbstractTensorWrapperper)

Whether the tensor wrapper is an adjoint wrapper
"""
isadjoint(::Union{LocalTensor, LeftEnvironmentTensor, RightEnvironmentTensor}) = false
isadjoint(::AdjointLocalTensor) = true

"""
    isLeftIsometric(A::AbstractTensorMap, isadjoint::Bool; tol::Float64=Defaults.tol_norm)
    isLeftIsometric(A::AbstractLocalTensor; tol::Float64=Defaults.tol_norm)

# Return
-`::Bool`: whether the R-leg local tensor `A` is left-orthogonal
"""
function isLeftIsometric(A::AbstractTensorMap, isadjoint::Bool; tol::Float64=Defaults.tol_norm)
    if numout(A) == 1 && numin(A) == 1 && isadjoint == false
        # BondTensor
        @tensor E[-1; -2] := A[1 -2] * A'[-1 1]
        return norm(E - id(domain(A))) < tol
    elseif numout(A) == 1 && numin(A) == 1 && isadjoint == true
        # AdjointBondTensor
        @tensor E[-1; -2] := A'[1 -2] * A[-1 1]
        return norm(E - id(codomain(A))) < tol
    elseif numout(A) == 2 && numin(A) == 1 && isadjoint == false
        # MPSTensor
        @tensor E[-1; -2] := A[1 2 -2] * A'[-1 1 2]
        return norm(E - id(domain(A))) < tol
    elseif numout(A) == 1 && numin(A) == 2 && isadjoint == true
        # AdjointMPSTensor
        @tensor E[-1; -2] := A'[1 2 -2] * A[-1 1 2]
        return norm(E - id(codomain(A))) < tol
    elseif numout(A) == 2 && numin(A) == 2 && isadjoint == false
        # MPOTensor
        @tensor E[-1; -2] := A[1 2 3 -2] * A'[3 -1 1 2]
        return norm(E - id(domain(A, 2))) < tol
    elseif numout(A) == 2 && numin(A) == 2 && isadjoint == true
        # AdjointMPOTensor
        @tensor E[-1; -2] := A'[1 2 3 -2] * A[3 -1 1 2]
        return norm(E - id(codomain(A, 2))) < tol
    elseif numout(A) == 2 && isadjoint == false
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif numout(A) == 2 && numin(A) == () && isadjoint == false
        #     (expr)
        #     return norm(E - id(domain(A, R-2))) < tol
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = (numind(A))
        # str_legs_A = prod(["$i " for i in 1:R-1]) * "-2"
        # str_legs_A′ = prod(["$i " for i in 3:R-1]) * "-1 1 2"
        # str_expr = "@tensor E[-1; -2] := A[$str_legs_A] * A'[$str_legs_A′]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    elseif numin(A) == 2 && isadjoint == true
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif numout(A) == () && numin(A) == 2 && isadjoint == true
        #     (expr)
        #     return norm(E - id(codomain(A, R-2))) < tol
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = numind(A)
        # str_legs_A′ = prod(["$i " for i in 1:R-1]) * "-2"
        # str_legs_A = prod(["$i " for i in 3:R-1]) * "-1 1 2"
        # str_expr = "@tensor E[-1; -2] := A'[$str_legs_A′] * A[$str_legs_A]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    else
        throw(ArgumentError("Unsupported space: $(space(A))"))
    end
end
function isLeftIsometric(A::AbstractLocalTensor; tol::Float64=Defaults.tol_norm)::Bool
    return isLeftIsometric(A.A, isadjoint(A); tol=tol)
end


"""
    isRightIsometric(A::AbstractTensorMap, isadjoint::Bool; tol::Float64=Defaults.tol_norm)
    isRightIsometric(A::AbstractLocalTensor; tol::Float64=Defaults.tol_norm)

# Return
-`::Bool`: whether the R-leg local tensor `A` is right-orthogonal
"""
function isRightIsometric(A::AbstractTensorMap, isadjoint::Bool; tol::Float64=Defaults.tol_norm)
    if numout(A) == 1 && numin(A) == 1 && isadjoint == false
        # BondTensor
        @tensor E[-1; -2] := A[-1 1] * A'[1 -2]
        return norm(E - id(codomain(A, 1))) < tol
    elseif numout(A) == 1 && numin(A) == 1 && isadjoint == true
        # AdjointBondTensor
        @tensor E[-1; -2] := A'[-1 1] * A[1 -2]
        return norm(E - id(domain(A, 1))) < tol
    elseif numout(A) == 2 && numin(A) == 1 && isadjoint == false
        # MPSTensor
        @tensor E[-1; -2] := A[-1 1 2] * A'[2 -2 1]
        return norm(E - id(codomain(A, 1))) < tol
    elseif numout(A) == 1 && numin(A) == 2 && isadjoint == true
        # AdjointMPSTensor
        @tensor E[-1; -2] := A'[-1 1 2] * A[2 -2 1]
        return norm(E - id(domain(A, 1))) < tol
    elseif numout(A) == 2 && numin(A) == 2 && isadjoint == false
        # MPOTensor
        @tensor E[-1; -2] := A[-1 1 2 3] * A'[2 3 -2 1]
        return norm(E - id(codomain(A, 1))) < tol
    elseif numout(A) == 2 && numin(A) == 2 && isadjoint == true
        # AdjointMPOTensor
        @tensor E[-1; -2] := A'[-1 1 2 3] * A[2 3 -2 1]
        return norm(E - id(domain(A, 1))) < tol
    elseif numout(A) == 2 && isadjoint == false
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif numout(A) == 2 && numin(A) == () && isadjoint == false
        #     (expr)
        #     return norm(E - id(codomain(A, 1))) < tol
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = (numind(A))
        # str_legs_A = "-1" * prod([" $i" for i in 1:R-1])
        # str_legs_A′ = prod(["$i " for i in 2:R-1]) * "-2 1"
        # str_expr = "@tensor E[-1; -2] := A[$str_legs_A] * A'[$str_legs_A′]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    elseif numin(A) == 2 && isadjoint == true
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif numout(A) == () && numin(A) == 2 && isadjoint == true
        #     (expr)
        #     return norm(E - id(domain(A, 1))) < tol
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = numind(A)
        # str_legs_A′ = "-1" * prod([" $i" for i in 1:R-1])
        # str_legs_A = prod(["$i " for i in 2:R-1]) * "-2 1"
        # str_expr = "@tensor E[-1; -2] := A'[$str_legs_A′] * A[$str_legs_A]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    else
        throw(ArgumentError("Unsupported space: $(space(A))"))
    end
end
function isRightIsometric(A::AbstractLocalTensor; tol::Float64=Defaults.tol_norm)::Bool
    return isRightIsometric(A.A, isadjoint(A); tol=tol)
end

"""
     leftorth(A::LocalTensor{R₁}; trunc = notrunc(), kwargs...)
     leftorth(A::AdjointLocalTensor{R₁}; trunc = notrunc(), kwargs...)

Left canonicalize a local tensor.

# Return
-`::LeftIsometricTensor{R₁}`: left isometric tensor
-`::BondTensor`: bond tensor

If `trunc = notrunc()`, use `TensorKit.leftorth`, otherwise, use `TensorKit.tsvd`.
Propagate `kwargs` to the TensorKit functions.
"""
function leftorth(A::LocalTensor{R₁}; trunc=notrunc(), kwargs...) where R₁
    if trunc == notrunc()
        Q, R = leftorth(A.A, (Tuple(1:R₁-1), (R₁,)); kwargs...)
        if R₁ == 2 || R₁ == 3
            return LocalTensor(Q), BondTensor(R), BondInfo(Q, :R)
        else
            return LocalTensor(permute(Q, (1, 2), Tuple(3:R₁))), BondTensor(R), BondInfo(Q, :R)
        end
    else
        u, s, vd, info = tsvd(A, (Tuple(1:R₁-1), (R₁,)); trunc=trunc, kwargs...)
        if R₁ == 2 || R₁ == 3
            return LocalTensor(u), LocalTensor(s * vd), info
        else
            return LocalTensor(permute(u, (1, 2), Tuple(3:R₁))), LocalTensor(s * vd), info
        end
    end
end
function leftorth(A::AdjointLocalTensor{R₁}; trunc=notrunc(), kwargs...) where R₁
    if trunc == notrunc()
        if R₁ == 2
            Q, R = leftorth(A.A, ((2,), (1,)); kwargs...)
            return AdjointLocalTensor(permute(Q, (2,), (1,))), AdjointBondTensor(permute(R, (2,), (1,))), BondInfo(Q, :R)
        else
            Q, R = leftorth(A.A, (Tuple(vcat(1:R₁-3, [R₁-1, R₁])), (R₁-2,)); kwargs...)
            return AdjointLocalTensor(permute(Q, Tuple(vcat(1:R₁-3, [R₁,])), (R₁-2, R₁-1))), AdjointBondTensor(permute(R, (2,), (1,))), BondInfo(Q, :R)
        end
    else
        if R₁ == 2
            u, s, vd, info = tsvd(A, ((2,), (1,)); trunc=trunc, kwargs...)
            return AdjointLocalTensor(permute(u, (2,), (1,))), AdjointBondTensor(permute(s * vd, (2,), (1,))), info
        else
            u, s, vd, info =  tsvd(A, (Tuple(vcat(1:R₁-3, [R₁-1, R₁])), (R₁-2,)); trunc=trunc, kwargs...)
            return AdjointLocalTensor(permute(u, Tuple(vcat(1:R₁-3, [R₁,])), (R₁-2, R₁-1))), AdjointBondTensor(permute(s * vd, (2,), (1,))), info
        end
    end
end

"""
    rightorth{R₂}(A::LocalTensor; trunc = notrunc(), kwargs...)
    rightorth{R₂}(A::AdjointLocalTensor; trunc = notrunc(), kwargs...)

Right canonicalize a local tensor.

# Return
-`::BondTensor`: bond tensor
-`::LocalTensor{R₂}`: right isometric tensor

If `trunc = notrunc()`, use `TensorKit.rightorth`, otherwise, use `TensorKit.tsvd`.
Propagate `kwargs` to the TensorKit functions.
"""
function rightorth(A::LocalTensor{R₂}; trunc=notrunc(), kwargs...) where R₂
    if trunc == notrunc()
        L, Q = rightorth(A.A, ((1,), Tuple(2:R₂)); kwargs...)
        if R₂ == 2
            return BondTensor(L), LocalTensor(Q), BondInfo(Q, :L)
        else
            return BondTensor(L), LocalTensor(permute(Q, (1, 2), Tuple(3:R₂))), BondInfo(Q, :L)
        end
    else
        u, s, vd, info = tsvd(A, ((1,), Tuple(2:R₂)); trunc=trunc, kwargs...)
        if R₂ == 2
            return BondTensor(u * s), LocalTensor(vd), info
        else
            return BondTensor(u * s), LocalTensor(permute(vd, (1, 2), Tuple(3:R₂))), info
        end
    end
end
function rightorth(A::AdjointLocalTensor{R₂}; trunc=notrunc(), kwargs...) where R₂
    if trunc == notrunc()
        if R₂ == 2
            L, Q = rightorth(A.A, ((2,), (1, )); kwargs...)
            return AdjointBondTensor(permute(L, (2,), (1,))), AdjointLocalTensor(permute(Q, (2,), (1,))), BondInfo(Q, :L)
        else
            L, Q = rightorth(A.A, ((R₂-1,), Tuple(vcat((1:R₂-2), [R₂,]))); kwargs...)
            return AdjointBondTensor(permute(L, (2,), (1,))), AdjointLocalTensor(permute(Q, Tuple(2:R₂-1), (1, R₂))), BondInfo(Q, :L)
        end
    else
        if R₂ == 2
            u, s, vd, info = tsvd(A, ((2,), (1, )); trunc=trunc, kwargs...)
            return AdjointBondTensor(permute(u * s, (2,), (1,))), AdjointLocalTensor(permute(vd, (2,), (1,))), info
        else
            u, s, vd, info = tsvd(A, ((R₂-1,), Tuple(vcat((1:R₂-2), [R₂,]))); trunc=trunc, kwargs...)
            return AdjointBondTensor(permute(u * s, (2,), (1,))), AdjointLocalTensor(permute(vd, Tuple(2:R₂-1), (1, R₂))), info
        end
    end
end
