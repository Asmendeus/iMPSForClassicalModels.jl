"""
    function pushmid(X₀::BondTensor, FL::LeftEnvironmentTensor{N}, FR::RightEnvironmentTensor{N})
        -> X::BondTensor
    function pushmid(X₀::BondTensor, env::BondEnvironment{N})
        -> X::BondTensor

Contract bond tensor and bond environment

     __            __
    |  | -- X₀ -- |  |
    |  |          |  |
    |  | ———————— |  |
    |  |          |  |
    |FL|     ⋮    |FR|  =  -- X ---
    |  |          |  |
    |  | ———————— |  |
    |  |          |  |
    |  | --   --- |  |
     ‾‾            ‾‾
"""
function pushmid(X₀::BondTensor, FL::LeftEnvironmentTensor{N}, FR::RightEnvironmentTensor{N}) where N
    if N == 2
        @tensor X[-1; -2] := FL.A[-1 1] * X₀.A[1 2] * FR.A[2 -2]
        return typeof(X₀)(X)
    elseif N == 3
        @tensor X[-1; -2] := FL.A[-1 1 2] * X₀.A[2 3] * FR.A[3 1 -2]
        return typeof(X₀)(X)
    elseif N == 4
        @tensor X[-1; -2] := FL.A[-1 1 2 3] * X₀.A[3 4] * FR.A[4 2 1 -2]
        return typeof(X₀)(X)
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif N == ()
        #     (expr)
        #     return typeof(X₀)(X)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # N = ()
        # str_legs_FL = "-1" * prod([" $i" for i in 1:N-1])
        # str_legs_FR = "$N" * prod([" $i" for i in N-2:-1:1]) * " -2"
        # str_expr = "@tensor X[-1; -2] := FL.A[$str_legs_FL] * X₀.A[$(N-1) $N] * FR.A[$str_legs_FR]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end
function pushmid(X₀::BondTensor, env::BondEnvironment{N}) where N
    return pushmid(X₀, env.FL, env.FR)
end

"""
    function pushmid(X₀::AjointBondTensor, FL::LeftEnvironmentTensor{N}, FR::RightEnvironmentTensor{N})
        -> X::AdjointBondTensor
    function pushmid(X₀::AjointBondTensor, env::BondEnvironment{N})
        -> X::AdjointBondTensor

Contract adjoint bond tensor and bond environment

     __            __
    |  | --   --- |  |
    |  |          |  |
    |  | ———————— |  |
    |  |          |  |
    |FL|     ⋮    |FR|  =  -- X ---
    |  |          |  |
    |  | ———————— |  |
    |  |          |  |
    |  | -- X₀ -- |  |
     ‾‾            ‾‾
"""
function pushmid(X₀::AdjointBondTensor, FL::LeftEnvironmentTensor{N}, FR::RightEnvironmentTensor{N}) where N
    if N == 2
        @tensor X[-1; -2] := FL.A[2 -2] * X₀.A[1 2] * FR.A[-1 1]
        return typeof(X₀)(X)
    elseif N == 3
        @tensor X[-1; -2] := FL.A[3 2 -2] * X₀.A[1 3] * FR.A[-1 2 1]
        return typeof(X₀)(X)
    elseif N == 4
        @tensor X[-1; -2] := FL.A[4 2 3 -2] * X₀.A[1 4] * FR.A[-1 3 2 1]
        return typeof(X₀)(X)
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif N == ()
        #     (expr)
        #     return typeof(X₀)(X)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # N = ()
        # str_legs_FL = "$N" * prod([" $i" for i in 2:N-1]) * " -2"
        # str_legs_FR = "-1" * prod([" $i" for i in N-1:-1:1])
        # str_expr = "@tensor X[-1; -2] := FL.A[$str_legs_FL] * X₀.A[1 $N] * FR.A[$str_legs_FR]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end
function pushmid(X₀::AdjointBondTensor, env::BondEnvironment{N}) where N
    return pushmid(X₀, env.FL, env.FR)
end

"""
    function pushmid(X₀::LocalTensor{R}, FL::LeftEnvironmentTensor{N}, O::AbstractVector{<:MPOTensor}, FR::RightEnvironmentTensor{N})
        -> X::LocalTensor{R}
    function pushmid(X₀::LocalTensor{R}, FL::LeftEnvironmentTensor{3}, O::MPOTensor, FR::RightEnvironmentTensor{3})
        -> X::LocalTensor{R}
    function pushmid(X₀::LocalTensor{R}, env::CenterEnvironment{N})
        -> X::LocalTensor{R}

Contract local tensor and center environment

           (a)
     __     |        __
    |  | -- X₀ ---- |  |
    |  |    |       |  |
    |  | —— O[1] —— |  |       (a)
    |  |    |       |  |        |
    |FL|    ⋮       |FR|  =  -- X -----
    |  |    |       |  |        |
    |  | —— O[W] —— |  |
    |  |    |       |  |
    |  | --   ----- |  |
     ‾‾              ‾‾
"""
function pushmid(X₀::LocalTensor{R}, FL::LeftEnvironmentTensor{N}, O::AbstractVector{<:MPOTensor}, FR::RightEnvironmentTensor{N}) where {R, N}
    N == length(O) + 2 || throw(ArgumentError("Mismatched number of EnvironmentTensors' legs and MPOTensors"))
    if R == 2
        throw(ArgumentError("Illegal behavior: center tensors are `BondTensor`"))
    elseif R == 3 && N == 3
        @tensor X[-1 -2; -3] := FL.A[-1 2 1] * X₀.A[1 3 4] * O[1].A[2 -2 3 5] * FR.A[4 5 -3]
        return typeof(X₀)(X)
    elseif R == 4 && N == 3
        @tensor X[-1 -2; -3 -4] := FL.A[-1 2 1] * X₀.A[1 3 -3 4] * O[1].A[2 -2 3 5] * FR.A[4 5 -4]
        return typeof(X₀)(X)
    elseif R == 3 && N == 4
        @tensor X[-1 -2; -3] := FL.A[-1 3 2 1] * X₀.A[1 4 6] * O[1].A[2 5 4 7] * O[2].A[3 -2 5 8] * FR.A[6 7 8 -3]
        return typeof(X₀)(X)
    elseif R == 4 && N == 4
        @tensor X[-1 -2; -3 -4] := FL.A[-1 3 2 1] * X₀.A[1 4 -3 6] * O[1].A[2 5 4 7] * O[2].A[3 -2 5 8] * FR.A[6 7 8 -4]
        return typeof(X₀)(X)
    else
        # ===== Generate the code you need =====
        # elseif R == () && N == ()
        #     (expr)
        #     return typeof(X₀)(X)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = ()
        # N = ()
        # str_legs_X = "-1 -2;" * prod([" -$i" for i in 3:R])
        # str_legs_FL = "-1" * prod([" $i" for i in N-1:-1:1])
        # str_legs_X₀ = "1 $N" * prod([" -$i" for i in 3:R-1]) * " $(2*N-2)"
        # str_O = prod(["* O[$w].A[$(w+1) $(w+N) $(w+N-1) $(w+2*N-2)] " for w in 1:N-3]) * "* O[$(N-2)].A[$(N-1) -2 $(2*N-3) $(3*N-4)] "
        # str_legs_FR = prod(["$i " for i in 2*N-2:3*N-4]) * "-$R"
        # str_expr = "@tensor X[$str_legs_X] := FL.A[$str_legs_FL] * X₀.A[$str_legs_X₀] $str_O* FR.A[$str_legs_FR]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end
function pushmid(X₀::LocalTensor{R}, FL::LeftEnvironmentTensor{3}, O::MPOTensor, FR::RightEnvironmentTensor{3}) where R
    return pushmid(X₀, FL, [O,], FR)
end
function pushmid(X₀::LocalTensor{R}, env::CenterEnvironment{N}) where {R, N}
    return pushmid(X₀, env.FL, env.O, env.FR)
end

"""
    function pushmid(X₀::AdjointLocalTensor{R}, FL::LeftEnvironmentTensor{N}, O::AbstractVector{<:MPOTensor}, FR::RightEnvironmentTensor{N})
        -> X::AdjointLocalTensor{R}
    function pushmid(X₀::AdjointLocalTensor{R}, FL::LeftEnvironmentTensor{3}, O::MPOTensor, FR::RightEnvironmentTensor{3})
        -> X::AdjointLocalTensor{R}
    function pushmid(X₀::AdjointLocalTensor{R}, env::CenterEnvironment{N})
        -> X::AdjointLocalTensor{R}

Contract adjoint local tensor and center environment

     __              __
    |  | --   ----- |  |
    |  |    |       |  |
    |  | —— O[1] —— |  |
    |  |    |       |  |        |
    |FL|    ⋮       |FR|  =  -- X -----
    |  |    |       |  |        |
    |  | —— O[W] —— |  |       (a)
    |  |    |       |  |
    |  | -- X₀ ---- |  |
     ‾‾     |        ‾‾
           (a)
"""
function pushmid(X₀::AdjointLocalTensor{R}, FL::LeftEnvironmentTensor{N}, O::AbstractVector{<:MPOTensor}, FR::RightEnvironmentTensor{N}) where {R, N}
    N == length(O) + 2 || throw(ArgumentError("Mismatched number of EnvironmentTensors' legs and MPOTensors"))
    if R == 2
        throw(ArgumentError("Illegal behavior: center tensors are `AdjointBondTensor`"))
    elseif R == 3 && N == 3
        @tensor X[-1; -2 -3] := FL.A[4 5 -2] * X₀.A[1 4 3] * O[1].A[5 3 -3 2] * FR.A[-1 2 1]
        return typeof(X₀)(X)
    elseif R == 4 && N == 3
        @tensor X[-1 -2; -3 -4] := FL.A[4 5 -3] * X₀.A[-1 1 4 3] * O[1].A[5 3 -4 2] * FR.A[-2 2 1]
        return typeof(X₀)(X)
    elseif R == 3 && N == 4
        @tensor X[-1; -2 -3] := FL.A[6 7 8 -2] * X₀.A[1 6 4] * O[2].A[7 4 5 2]* O[1].A[8 5 -3 3]* FR.A[-1 3 2 1]
        return typeof(X₀)(X)
    elseif R == 4 && N == 4
        @tensor X[-1 -2; -3 -4] := FL.A[6 7 8 -3] * X₀.A[-1 1 6 4] * O[2].A[7 4 5 2]* O[1].A[8 5 -4 3]* FR.A[-2 3 2 1]
        return typeof(X₀)(X)
    else
        # ===== Generate the code you need =====
        # elseif R == () && N == ()
        #     (expr)
        #     return typeof(X₀)(X)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = ()
        # N = ()
        # str_legs_X = prod(["-$i " for i in 1:R-3]) * "-$(R-2); -$(R-1) -$R"
        # str_legs_FL = prod(["$i " for i in 2*N-2:3*N-4]) * "-$(R-1)"
        # str_legs_X₀ = prod(["-$i " for i in 1:R-3]) * "1 $(2*N-2) $N"
        # str_O = prod(["* O[$w].A[$(3*N-3-w) $(2*N-2-w) $(2*N-1-w) $(N-w)]" for w in N-2:-1:2]) * "* O[1].A[$(3*N-4) $(2*N-3) -$R $(N-1)]"
        # str_legs_FR = "-$(R-2)" * prod([" $i" for i in N-1:-1:1])
        # str_expr = "@tensor X[$str_legs_X] := FL.A[$str_legs_FL] * X₀.A[$str_legs_X₀] $str_O* FR.A[$str_legs_FR]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end
function pushmid(X₀::AdjointLocalTensor{R}, FL::LeftEnvironmentTensor{3}, O::MPOTensor, FR::RightEnvironmentTensor{3}) where R
    return pushmid(X₀, FL, [O,], FR)
end
function pushmid(X₀::AdjointLocalTensor{R}, env::CenterEnvironment{N}) where {R, N}
    return pushmid(X₀, env.FL, env.O, env.FR)
end
