"""
    pushright(X₀::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}, A::LocalTensor{R}, B::AdjointLocalTensor{R})
        -> X::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}

Contract transfer matrix environment and right environment tensor
    -- A --       --
       |   |        |
       |   X₀  =    X
       |   |        |
    -- B --       --
"""
function pushright(X₀::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}, A::LocalTensor{R}, B::AdjointLocalTensor{R}) where R
    if R == 2
        @tensor X[-1; -2] := X₀.A[1 2] * A.A[-1 1] * B.A[2 -2]
        return typeof(X₀)(X)
    elseif R == 3
        @tensor X[-1; -2] := X₀.A[2 3] * A.A[-1 1 2] * B.A[3 -2 1]
        return typeof(X₀)(X)
    elseif R == 4
        @tensor X[-1; -2] := X₀.A[2 3] * A.A[-1 1 4 2] * B.A[4 3 -2 1]
        return typeof(X₀)(X)
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        #     return typeof(X₀)(X)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = ()
        # str_legs_A = "-1 1" * prod([" $i" for i in 4:R]) * " 2"
        # str_legs_B = prod(["$i " for i in 4:R]) * "3 -2 1"
        # str_expr = "@tensor X[-1; -2] := X₀.A[2 3] * A.A[$str_legs_A] * B.A[$str_legs_B]"
        # eval(Meta.parse(str_expr))
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end

"""
    pushright(X₀::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}, A::AbstractVector{<:LocalTensor{R}}, B::AbstractVector{<:AdjointLocalTensor{R}})
        -> X::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}
    pushright(X₀::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}, t::TransferMatrix{L, R})
        -> X::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}

Iteratively contract transfer matrix and right environment tensor
    -- A[1] -- ... -- A[L] --       --
       |              |      |        |
       |              |      X₀  =    X
       |              |      |        |
    -- B[1] -- ... -- B[L] --       --
"""
function pushright(X₀::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}, A::AbstractVector{<:LocalTensor{R}}, B::AbstractVector{<:AdjointLocalTensor{R}}) where R
    (L = length(A)) == length(B) || throw(ArgumentError("Mismatched lengths: $(length(A)) ≠ $(length(B))"))
    X = deepcopy(X₀)
    for l in L:-1:1
        X = pushright(X, A[l], B[l])
    end
    return X
end
function pushright(X₀::Union{RightEnvironmentTensor{2}, BondTensor, AdjointBondTensor}, t::TransferMatrix{L, R}) where {L, R}
    return pushright(X₀, t.A, t.B)
end

"""
    pushright(X₀::RightEnvironmentTensor{N}, A::LocalTensor{R}, O::AbstractVector{MPOTensor}, B::AdjointLocalTensor{R})
        -> X::RightEnvironmentTensor{N}
    pushright(X₀::RightEnvironmentTensor{3}, A::LocalTensor{R}, O::MPOTensor, B::AdjointLocalTensor{R})
        -> X::RightEnvironmentTensor{3}

Contract channel environment and right environment tensor
                __          __
    -- A ----- |  |     -- |  |
       |       |  |        |  |
    —— O[1] —— |  |     —— |  |
       |       |  |        |  |
       ⋮       |X₀|  =    ⋮ |X |
       |       |  |        |  |
    —— O[W] —— |  |     —— |  |
       |       |  |        |  |
    -- B ----- |  |     -- |  |
                ‾‾          ‾‾
"""
function pushright(X₀::RightEnvironmentTensor{N}, A::LocalTensor{R}, O::AbstractVector{MPOTensor}, B::AdjointLocalTensor{R}) where {N, R}
    N == length(O) + 2 || throw(ArgumentError("Mismatched number of RightEnvironmentTensors' legs and MPOTensors"))
    if R == 2
        throw(ArgumentError("Illegal behavior: boundary tensors are `BondTensor` and `AdjointBondTensor`"))
    elseif R == 3 && N == 3
        @tensor X[-1 -2; -3] := X₀.A[1 2 3] * A.A[-1 4 1] * O[1].A[-2 5 4 2] * B.A[3 -3 5]
        return typeof(X₀)(X)
    elseif R == 4 && N == 3
        @tensor X[-1 -2; -3] := X₀.A[1 2 3] * A.A[-1 4 6 1] * O[1].A[-2 5 4 2] * B.A[6 3 -3 5]
        return typeof(X₀)(X)
    elseif R == 3 && N == 4
        @tensor X[-1 -2 -3; -4] := X₀.A[1 2 3 4] * A.A[-1 5 1] * O[1].A[-2 6 5 2] * O[2].A[-3 7 6 3] * B.A[4 -4 7]
        return typeof(X₀)(X)
    elseif R == 4 && N == 4
        @tensor X[-1 -2 -3; -4] := X₀.A[1 2 3 4] * A.A[-1 5 8 1] * O[1].A[-2 6 5 2] * O[2].A[-3 7 6 3] * B.A[8 4 -4 7]
        return typeof(X₀)(X)
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == () && N == ()
        #     (expr)
        #     return typeof(X₀)(X)
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = ()
        # N = ()
        # str_legs_X = prod(["-$i " for i in 1:N-1]) * "; -$N"
        # str_legs_X₀ = "1" * prod([" $i" for i in 2:N])
        # str_legs_A = "-1 $(N+1)" * prod([" $i" for i in 2*N:2*N+R-4]) * " 1"
        # str_O = prod(["* O[$w].A[-$(w+1) $(N+w+1) $(N+w) $(w+1)] " for w in 1:N-2])
        # str_legs_B = prod(["$i " for i in 2*N:2*N+R-4]) * "$N -$N $(2*N-1)"
        # str_expr = "@tensor X[$str_legs_X] := X₀.A[$str_legs_X₀] * A.A[$str_legs_A] $str_O* B.A[$str_legs_B]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end
function pushright(X₀::RightEnvironmentTensor{3}, A::LocalTensor{R}, O::MPOTensor, B::AdjointLocalTensor{R}) where R
    return pushright(X₀, A, [O,], B)
end

"""
    pushright(X₀::RightEnvironmentTensor{N}, A::AbstractVector{<:LocalTensor{R}}, O::AbstractMatrix{MPOTensor}, B::AbstractVector{<:AdjointLocalTensor{R}})
        -> X::RightEnvironmentTensor{N}
    pushright(X₀::RightEnvironmentTensor{N}, env::ChannelEnvironment{N, L, R})
        -> X::RightEnvironmentTensor{N}

Contract channel environment tensor and right environment
                                     __          __
    -- A[1] ----- ... -- A[L] ----- |  |     -- |  |
       |                 |          |  |        |  |
    —— O[1, 1] —— ... —— O[1, L] —— |  |     —— |  |
       |                 |          |  |        |  |
       ⋮                  ⋮          |X₀|  =   ⋮ |X |
       |                 |          |  |        |  |
    —— O[W, 1] —— ... —— O[W, L] —— |  |     —— |  |
       |                 |          |  |        |  |
    -- B[1] ----- ... -- B[L] ----- |  |     -- |  |
                                     ‾‾          ‾‾
"""
function pushright(X₀::RightEnvironmentTensor{N}, A::AbstractVector{<:LocalTensor{R}}, O::AbstractMatrix{MPOTensor}, B::AbstractVector{<:AdjointLocalTensor{R}}) where {N, R}
    N == size(O, 1) + 2 || throw(ArgumentError("Mismatched widths: $N ≠ $(size(O, 1)+2)"))
    (L = length(A)) == size(O, 2) == length(B) || throw(ArgumentError("Mismatched lengths: ($L, $(length(A)), $(size(O, 2)), $(length(B)))"))
    X = deepcopy(X₀)
    for l in L:-1:1
        X = pushright(X, A[l], O[:, l], B[l])
    end
    return X
end
function pushright(X₀::RightEnvironmentTensor{N}, env::ChannelEnvironment{N, L, R}) where {N, L, R}
    return pushright(X₀, env.A, env.O, env.B)
end
