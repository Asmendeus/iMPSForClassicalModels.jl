"""
    contract(FL::LeftEnvironmentTensor{N}, env::ChannelEnvironment{N, L, R}, FR::RightEnvironmentTensor{N}) -> ::Number
    contract(AC::LocalTensor{R}, env::CenterEnvironment{N}, AC′::AdjointLocalTensor{R}) -> ::Number
    contract(C::BondTensor, env::BondEnvironment{N}, C′::AdjointBondTensor) -> ::Number
    contract(env::BondEnvironment{N}) -> ::Number

Contract losed tensor network into a single number
1.
         __                                   __
        |  | -- A[1] ----- ... -- A[L] ----- |  |
        |  |    |                 |          |  |
        |  | —— O[1, 1] —— ... —— O[1, L] —— |  |
        |  |    |                 |          |  |
        |FL|    ⋮                  ⋮          |FR|
        |  |    |                 |          |  |
        |  | —— O[W, 1] —— ... —— O[W, L] —— |  |
        |  |    |                 |          |  |
        |  | -- B[1] ----- ... -- B[L] ----- |  |
         ‾‾                                   ‾‾
2.
         __              __
        |  | -- A ----- |  |
        |  |    |       |  |
        |  | —— O[1] —— |  |
        |  |    |       |  |
        |FL|    ⋮       |FR|
        |  |    |       |  |
        |  | —— O[W] —— |  |
        |  |    |       |  |
        |  | -- B ----- |  |
         ‾‾              ‾‾
3.
         __            __
        |  | -- CA -- |  |
        |  |          |  |
        |  | ———————— |  |
        |  |          |  |
        |FL|    ⋮     |FR|
        |  |          |  |
        |  | ———————— |  |
        |  |          |  |
        |  | -- CB -- |  |
         ‾‾            ‾‾
4.
         __       __
        |  | --- |  |
        |  |     |  |
        |  | ——— |  |
        |  |     |  |
        |FL|  ⋮  |FR|
        |  |     |  |
        |  | ——— |  |
        |  |     |  |
        |  | --- |  |
         ‾‾       ‾‾
"""
function contract(FL::LeftEnvironmentTensor{N}, env::ChannelEnvironment{N, L, R}, FR::RightEnvironmentTensor{N}) where {N, L, R}
    tmp = pushleft(FL, env)
    if N == 3
        @tensor E = tmp.A[1 2 3] * FR.A[3 2 1]
        return E
    elseif N == 4
        @tensor E = tmp.A[1 2 3 4] * FR.A[4 3 2 1]
        return E
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif N == ()
        #     (expr)
        #     return E
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # N = ()
        # str_legs_tmp = "1" * prod([" $i" for i in 2:N])
        # str_legs_FR = prod(["$i " for i in N:-1:2]) * "1"
        # str_expr = "@tensor E = tmp.A[$str_legs_tmp] * FR.A[$str_legs_FR]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end
function contract(AC::LocalTensor{R}, env::CenterEnvironment{N}, AC′::AdjointLocalTensor{R}) where {N, R}
    tmp = pushmid(AC, env)
    if R == 3
        @tensor E = tmp.A[1 2 3] * AC′.A[3 1 2]
        return E
    elseif R == 4
        @tensor E = tmp.A[1 2 3 4] * AC′.A[3 4 1 2]
        return E
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif R == ()
        #     (expr)
        #     return E
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # R = ()
        # str_legs_tmp = "1" * prod([" $i" for i in 2:R])
        # str_legs_AC′ = prod(["$i " for i in 3:R]) * "1 2"
        # str_expr = "@tensor E = tmp.A[$str_legs_tmp] * AC′.A[$str_legs_AC′]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    end
end
function contract(C::BondTensor, env::BondEnvironment{N}, C′::AdjointBondTensor) where N
    tmp = pushmid(C, env)
    @tensor E = tmp.A[1 2] * C′.A[2 1]
    return E
end
function contract(env::BondEnvironment{N}) where N
    if N == 2
        @tensor E = env.FL[1 2] * env.FR[2 1]
    elseif N == 3
        @tensor E = env.FL[1 2 3] * env.FR[3 2 1]
    elseif N == 4
        @tensor E = env.FL[1 2 3 4] * env.FR[4 3 2 1]
    else
        throw(ArgumentError("Undefined behavior. You can add your requirements to the function based on the comments in the source code at the error location."))
        # ===== Generate the code you need =====
        # elseif N == ()
        #     (expr)
        #     return E
        # ==========
        # where (expr) can be generated by `str_expr` below:

        # N = ()
        # str_legs_FL = "1" * prod([" $i" for i in 2:N])
        # str_legs_FR = prod(["$i " for i in N:-1:2]) * "1"
        # str_expr = "@tensor E = env.FL[$str_legs_FL] * env.FR[$str_legs_FR]"
        # ==========
        # Dev memo: No method was found for `eval` to be applied to function scopes
    return E
    end
end
